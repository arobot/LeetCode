### 关键字
- 有序数组
- 原地删除
- 不能使用额外数组空间
- nums已按照升序排列
- 额外空间限定O(1)

### 方案

#### 1. 朴素方案
通过对题目的分析，数组内会涉及到元素移动，此时限定了算法的时间复杂度的上限为O(${N}$)。额外空间可用O(1)，表明可以使用有限个常量作为临时参数。

故考虑双指针方案为第一个解决方案。

```
  [0,0,1,1,1,2,2,3,3,4]
i  0
j      2
```

第一次，`i`为第一个元素，`j`找到第一个非重复元素，并将其赋值给`i+1`,并从`j`当前位置继续往后遍历。

遍历完毕后，返回`i`值即可。

```java
    public static int removeDuplicates(int[] nums) {
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] > nums[i]) {
                nums[++i] = nums[j];
            }
        }
        return ++i;
    }
```

#### 2. 优化方案
上述方案的空间消耗排名仅击败了`5.1%`，看来优化空间还有不少。首先，可以考虑移除掉变量`j`试试看。