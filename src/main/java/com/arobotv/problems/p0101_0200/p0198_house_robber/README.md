# 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：

```txt
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 2：

```txt
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

## 分析

由于间隔问题的存在，所以本题的目标是在不同的间隔条件下记录下可以获取的最高金额。给定数组`dp[length][2]`用来保存经过房屋时所窃取金额的数量。即`dp[i]`为到访房间`i`时可以窃取的最大数量。其中，`dp[i][0]`为当前房间不下手所窃取的金额，`dp[i][1]`为下手所窃取的金额。

假设房间`[2,7,9,3,1,2]`

初始状态：

```java
dp[0][0] = 0,dp[0][1] = 2;
```

此时考虑状态转移方程：当他到了房间`i`时，如果他在当前房间拿取，则在上一个房间一定不拿取，取值`dp[i-1][0]`；在当前房间不拿，则上一个房间可以拿也可以不拿，就看哪个值比较高。

```java
dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]);
dp[i][1] = dp[i-1][0]+house[i];
```

### 1.动态规划

在光顾了最后一个房间后，仍然需要比较是拿还是不拿得好啊。

```java
    public int rob(int[] nums) {
        int[][] dp = new int[nums.length][2];
        dp[0][0] = 0;
        dp[0][1] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = dp[i - 1][0] + nums[i];
        }
        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
    }
```

> 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
>
> 内存消耗：35.7 MB, 在所有 Java 提交中击败了64.64%的用户

### 2.动态规划优化

实际上，每次光顾的时候只会去回溯上一个房间决策的结果，可以放弃掉数组。

```java
    public int rob2(int[] nums) {
        int rob = nums[0];
        int through = 0;
        for (int i = 1; i < nums.length; i++) {
            int tmp = through;
            through = Math.max(through, rob);
            rob = tmp + nums[i];
        }
        return Math.max(rob, through);
    }
```

> 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
>
> 内存消耗：35.8 MB, 在所有 Java 提交中击败了57.31%的用户
