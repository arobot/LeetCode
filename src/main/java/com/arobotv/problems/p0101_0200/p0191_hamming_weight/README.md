# 位1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为**汉明重量**）。

提示：

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用`二进制补码`记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 `-3`。

## 分析

二进制数由`0`和`1`构成，同时，二进制运算`&`能够提取相同的位，而`|`则提取包含`1`的位.需要统计一个整型常量中位1的数量，可以简单的通过右移该常数，并统计最低位是否为1进行。

### 1.暴力求解

将常数每次右移1位，并将其与1相与，判断是否是1即可。

```java
    public int hammingWeight(int n) {
        int weight = 0;
        do {
            weight += n & 1;
            n = n >>> 1;
        } while (n != 0);
        return weight;
    }
```

> 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
>
> 内存消耗：35.3 MB, 在所有 Java 提交中击败了60.04%的用户

### 2.官方解法

```java
    public static int bitCount(int i) {
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    }
```

举例：

```txt
i= 11
step1.  [01010101010101010101010101010101]          右移一位后取每两位的低位
        1011-0101 = 0110                            
step2.  [00110011001100110011001100110011]          右移两位后取1
        0010+0001 = 0011
step3.  [00001111000011110000111100001111]          右移4位后取1
        0011+0000 = 0011
step4.                                              右移8位
        0011+0000 = 0011
step5.                                              右移16位
        0011
return  0011&00111111
```
