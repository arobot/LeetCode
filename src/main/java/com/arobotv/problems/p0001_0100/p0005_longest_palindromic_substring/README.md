# 最长回文字串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

## 分析

对于每一个字母来讲，都有两种状态。要么是回文串的中心，要么就是回文串的边缘。

当它能够成为左边回文串的边缘时，我们把它标记为边缘，并记录下它离中心的距离。或者它就是独立成为一个中心，标记下自己的位置即可。

### 1. 动态规划

通过上面的分析，使用动态规划来求解问题。假设一个和字符串长度相同的动态规划数组`dp[len][2]`,其中`dp[i][0]`记录该位置距离中心的距离。`dp[i][1]`表示该回文串是否存在单个的中心，`1`表示存在。

所以，有初始化状态如下：

```java
dp[0][0] = 0;
dp[0][1] = 0;
```

状态转移方程就出来了：

```java
    int distance = dp[i-1][0];
    if(distance == 0 && string.charAt(i - 1) == string.charAt(i)){
        dp[i][0] = 1;
        dp[i][1] = 1;
    }else{
        int mirrorPos = i - 1 - distance - 1 - dp[i-1][1];
        if(mirrorPos > -1 && string.charAt(mirrorPos) == string.charAt(i)){
            dp[i][0] = dp[i-1][0] + 1;
            dp[i][1] = dp[i-1][1];
        }else{
            dp[i][0] = 0;
            dp[i][1] = 0;
        }
    }
```
