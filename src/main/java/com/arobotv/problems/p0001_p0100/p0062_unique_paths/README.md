# 不同路径

## 分析

首先已知的是机器人每次只能向下或者向右行进。假设只有一个格子，那么只有一条路径。假设有多个格子的话，到达该格子的路径是该格子上方和左方格子可达路径可能性的总和。

所以，上方的逻辑就是状态转移方程了。通过机器人的前进方向可得首行和首列的可能性全部都是`1`。

### 1. 动态规划

原本创建一个动态规划的数组应该是`new int[m][n]`,用来存储每一个格子的可能性。但在实际执行扫描的过程，可以按照每一行来，或者是每一列来。代码中就按列执行扫描，将每一次扫描的结果就地存储在当前格子。以此将`O(mn)`的空间复杂度降低到`O(m)`.

```java
    public int uniquePaths(int m, int n) {
        int[] paths = new int[m];
        Arrays.fill(paths, 1);
        while (n-- > 1) {
            for (int i = 1; i < m; i++) {
                paths[i] = paths[i] + paths[i - 1];
            }
        }
        return paths[m - 1];
    }
```

> 执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
>
> 内存消耗：38.1 MB, 在所有 Java 提交中击败了22.92%的用户

通过对上述规律的总结，也能得出这是一个`杨辉三角`的应用
